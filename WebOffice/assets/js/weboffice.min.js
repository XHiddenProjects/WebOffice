$(document).ready(function(){
    $('[wo-clock]').each(function() {
        const $clock = $(this);
        const format = $clock.attr('wo-clock-format') || 'auto';
        function updateClock() {
            const now = new Date(),
            tf = new TimeFormat(now.toISOString().replace(/T/,' ').replace(/Z/,''));
            $clock.html(format==='auto' 
                ? new Intl.DateTimeFormat(undefined, { 
                    year: 'numeric', 
                    month: '2-digit', 
                    day: '2-digit', 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit' 
                }).format(now) 
                : tf.format(format));
            const hrs = now.getHours();
            if(hrs>=0&&hrs<12) $clock.attr('wo-clock-style','morning');
            else if(hrs>=12&&hrs<18) $clock.attr('wo-clock-style','afternoon');
            else if(hrs>=18&&hrs<21) $clock.attr('wo-clock-style','evening');
            else $clock.attr('wo-clock-style','night');
        }

        // Initial call
        updateClock();

        // Update every second
        setInterval(updateClock, 1000);
    });
    //GPS Map
    let gps, tiles;
    if($('#device-map').length>0){
        gps = new L.Map('device-map').setView([0,0],2),//Init view
        tiles = new L.TileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: ''
        }).addTo(gps);
    }
    const deviceMarkers = {},
    deviceCircles = {};
    //GPS color
    let hexList = [];
    XMLParse(`${BASE}/data/gps.xml`).then((e)=>{
        const hexColors = Array.from(e.getElementsByTagName('color')).map(color=>color.getAttribute('hex'));
        hexList = hexColors;
    });
    navigator.geolocation.watchPosition(function(position){
        //Update
        $.ajax({
            url: `${BASE}/vendor/GPS.php`,
            method: 'POST',
            data:{
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                accuracy: position.coords.accuracy,
                altitude: position.coords.altitude,
                altitudeAccuracy: position.coords.altitudeAccuracy,
                speed: position.coords.speed
            },
            success: function(results){
                if(!results.success) alert(results.msg);
            }
        },function(error){console.error(error.code);})
        //GET
        if($('#device-map').length>0){
        const genIcon = (iconColor)=>{
            return `
                <div style="
                display: flex;
                align-items: center;
                justify-content: center;
                width: 30px;
                height: 30px;
                ">
                <i class="fa-solid fa-location-dot" style="color: ${iconColor}; font-size: 30px;"></i>
                </div>
            `;
        }
        $.ajax({
            url: `${BASE}/vendor/GPS.php`,
            method: 'GET',
            dataType: 'JSON',
            success:function(results){
                let index=0;
                results.forEach(device=>{
                    const {serial_number, latitude, longitude, accuracy, timestamp, altitudeAccuracy} = device;
                    if(deviceMarkers[serial_number])
                        deviceMarkers[serial_number].setLatLng([latitude,longitude]).getPopup().setContent(`Device: ${serial_number} @ ${new Date(timestamp).toLocaleString()}`).update();
                    else
                        deviceMarkers[serial_number] = new L.Marker([latitude,longitude],{
                            icon: new L.DivIcon({
                                html: genIcon(hexList[index]),
                                className: '',
                                iconSize: [30, 30],
                                iconAnchor: [15, 28]
                            })
                        }).addTo(gps).bindPopup(`Device: ${serial_number} @ ${new Date(timestamp).toLocaleString()}`,{
                            offset: new L.Point(0,-10)
                        });
                    if(accuracy!==null&&accuracy!==undefined){
                        let precise = altitudeAccuracy ? accuracy : Math.MeasurementConverter.convert(accuracy,'m','px');
                        if(deviceCircles[serial_number]){
                            deviceCircles[serial_number].setLatLng([latitude, longitude]);
                            deviceCircles[serial_number].setRadius(precise);
                        }else{
                            deviceCircles[serial_number] = new L.Circle([latitude, longitude], {
                                radius: precise, // in pixels
                                color: hexList[index],
                                fillColor: hexList[index],
                                fillOpacity: 0.3,
                                weight: 1
                            }).addTo(gps);
                        }
                    }
                    index++;
                });
            }
            },function(error){console.error(error.code);})
        }
    },(err) => {
        console.warn(`ERROR(${err.code}): ${err.message}`);
    },{
        enableHighAccuracy: true
    });

    $('[wo-weather]').each(function() {
        const $weather = $(this);
        const location = navigator.geolocation;
        if (!location) {
            $weather.html('Geolocation is not supported by this browser.');
            return;
        }
        location.getCurrentPosition(showPosition, showError);
        // Update location on watch
        location.watchPosition(showPosition, showError);

        function showPosition(position) {
            const lat = position.coords.latitude;
            const lon = position.coords.longitude;

            let city, state;
            fetch(`https://api.weather.gov/points/${lat},${lon}`)
                .then(response => response.json())
                .then(data => {
                    if (!data.properties || !data.properties.forecastHourly) {
                        $weather.html('Weather data not available.');
                        return;
                    }
                    city = data.properties.relativeLocation.properties.city;
                    state = data.properties.relativeLocation.properties.state;
                    return fetch(data.properties.forecastHourly);
                })
                .then(response => response.json())
                .then(data => {
                    if (!data.properties || !data.properties.periods || data.properties.periods.length === 0) {
                        $weather.html('Weather data not available.');
                        return;
                    }
                    // Find the period for the current hour
                    const now = new Date();
                    const currentHour = now.getHours();
                    const periods = data.properties.periods;
                    const currentPeriod = periods.find(period => {
                        const periodDate = new Date(period.startTime);
                        return periodDate.getHours() === currentHour &&
                            periodDate.getDate() === now.getDate() &&
                            periodDate.getMonth() === now.getMonth() &&
                            periodDate.getFullYear() === now.getFullYear();
                    }) || periods[0]; // fallback to first period if not found

                    // Calculate high and low temperatures for all periods
                    const temperatures = periods.map(period => period.temperature);
                    const high = Math.max(...temperatures);
                    const low = Math.min(...temperatures);
                    $weather.html(`
                        <div class="weather-info">
                            <div class="section-1">
                                <img src="${currentPeriod.icon}" alt="${currentPeriod.shortForecast}" title="${currentPeriod.shortForecast}">
                                <div class="condition-container">
                                    <div class="location">${city}, ${state}</div>
                                    <div class="condition">${currentPeriod.shortForecast}</div>
                                    <div class="precipitation">Precipitation ${currentPeriod.probabilityOfPrecipitation !== undefined && currentPeriod.probabilityOfPrecipitation !== null ? currentPeriod.probabilityOfPrecipitation.value + '%' : 'N/A'}</div>
                                </div>
                            </div>
                            <div class="temperature-container">
                                <div class="temperature">${currentPeriod.temperature}°${currentPeriod.temperatureUnit}</div>
                                <div>
                                    <span class="temperature-high">${high}°${currentPeriod.temperatureUnit}</span>/<span class="temperature-low">${low}°${currentPeriod.temperatureUnit}</span>
                                </div>
                            </div>
                        </div>
                    `);
                })
                .catch(error => {
                    console.error('Error fetching weather data:', error);
                    $weather.html('Error fetching weather data.');
                });
        }
        function showError(error) {
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    $weather.html('User denied the request for Geolocation.');
                    break;
                case error.POSITION_UNAVAILABLE:
                    $weather.html('Location information is unavailable.');
                    break;
                case error.TIMEOUT:
                    $weather.html('The request to get user location timed out.');
                    break;
                case error.UNKNOWN_ERROR:
                    $weather.html('An unknown error occurred.');
                break;
            }
        }
    });
    LANGUAGES.then((i)=>{
        $('#dashboard-nav li[data-item-new]').each((_,e)=>{$(e).html(`${$(e).html()} <span class="badge text-bg-info bg-gradient float-end">${i.navbar.new}</span>`);});
        $.ajax({
        url: `${BASE}/api/tickets`,
        dataType: "JSON",
        method: "GET",
        success: function(results) {
    $('#supportTickets-table').DataTable({
        data: results.map(item => ({
            ticket_id: item.ticket_id,
            subject: item.subject,
            description: item.description,
            status: `<span class="badge ticket-status ticket-status-${item.status.toLowerCase()}">${item.status.replace('_',' ').capitalizeFirstChar()}</span>`,
            category: `<span class="badge ticket-category-${item.category.replace(/ |\//,'-').toLowerCase()}">${item.category}</span>`,
            priority: `<span class="badge ticket-priority ticket-priority-${item.priority.toLowerCase()}">${item.priority}</span>`,
            created_at: new Date(item.created_at).toLocaleString(),
            assigned_to: item.assigned_to??''
        })),
        columns: [
            { data: 'ticket_id' },
            { data: 'subject' },
            { data: 'description' },
            { data: 'status' },
            { data: 'category' },
            { data: 'priority' },
            { data: 'created_at' },
            { data: 'assigned_to' }
        ],
        responsive: true
    });
    if($('#supportTickets-table tbody tr td').length>1){
        $('#supportTickets-table tbody tr').each((_,e)=>{
            $(e).on('click',()=>{
                window.open(`${window.location.href}/read?ticket=${$($(e).find('td')[0]).text()}`,'_self');
            });
        });
    }


            // Initialize totals
            let totalOnHold = 0;
            let totalOpen = 0;
            let totalDueToday = 0;
            let totalUnassigned = 0;

            function getWeekNumber(date) {
                const firstDayOfYear = new Date(date.getFullYear(), 0, 1);
                const pastDaysOfYear = (date - firstDayOfYear + 86400000) / 86400000;
                return Math.ceil(pastDaysOfYear / 7);
            }

            const weeksInYear = 52;
            const weeklyCounts = {
                on_hold: Array(weeksInYear).fill(0),
                open_tickets: Array(weeksInYear).fill(0),
                due_tickets_today: Array(weeksInYear).fill(0),
                unassigned: Array(weeksInYear).fill(0)
            };

            

            const today = new Date();

            results.forEach(ticket => {
                const createdDate = new Date(ticket.created_at);
                const weekNum = getWeekNumber(createdDate);
                if (weekNum >= 1 && weekNum <= weeksInYear) {
                    if (ticket.status === 'on_hold') {
                        weeklyCounts.on_hold[weekNum - 1]++;
                        totalOnHold++;
                    }
                    if (ticket.status === 'open') {
                        weeklyCounts.open_tickets[weekNum - 1]++;
                        totalOpen++;
                    }
                    if (createdDate.toDateString() === today.toDateString()) {
                        weeklyCounts.due_tickets_today[weekNum - 1]++;
                        totalDueToday++;
                    }
                    if (!ticket.assigned_to || ticket.assigned_to.trim() === '') {
                        weeklyCounts.unassigned[weekNum - 1]++;
                        totalUnassigned++;
                    }
                }
            });

            // Update the total counts in your <h2> elements
            // Calculate the overall total
            const overallTotal = totalOnHold + totalOpen + totalDueToday + totalUnassigned;

            // Helper function to get class based on percentage
            function getStatusClass(percentage) {
                if (percentage > 0) {
                    return 'avg-status-positive';
                } else if (percentage < 0) {
                    return 'avg-status-negative';
                } else {
                    return ''; // or 'avg-status-neutral' if you have such class
                }
            }

            // Calculate percentages and update HTML
            const onHoldPercent = overallTotal ? (totalOnHold / overallTotal) * 100 : 0;
            const openTicketsPercent = overallTotal ? (totalOpen / overallTotal) * 100 : 0;
            const dueTodayPercent = overallTotal ? (totalDueToday / overallTotal) * 100 : 0;
            const unassignedPercent = overallTotal ? (totalUnassigned / overallTotal) * 100 : 0;

            $('.desk-onHold-label').html(`${totalOnHold} <span class="avg-status ${getStatusClass(onHoldPercent)}">${onHoldPercent.toFixed(2)}%</span>`);
            $('.desk-openTickets-label').html(`${totalOpen} <span class="avg-status ${getStatusClass(openTicketsPercent)}">${openTicketsPercent.toFixed(2)}%</span>`);
            $('.desk-dtt-label').html(`${totalDueToday} <span class="avg-status ${getStatusClass(dueTodayPercent)}">${dueTodayPercent.toFixed(2)}%</span>`);
            $('.desk-unassigned-label').html(`${totalUnassigned} <span class="avg-status ${getStatusClass(unassignedPercent)}">${unassignedPercent.toFixed(2)}%</span>`);

            // Generate week labels
            const weeks = Array.from({ length: weeksInYear }, (_, i) => `Week ${i + 1}`);


            // Initialize a structure to hold counts per day of week and priority
            const daysOfWeek = i.dates.days;
            const priorities = [
                i?.priority?.low || 'Low',
                i?.priority?.medium || 'Medium',
                i?.priority?.high || 'High',
                i?.priority?.urgent || 'Urgent'
            ];

            let weeklyPriorityCounts = {};
            priorities.forEach(priority => {
                weeklyPriorityCounts[priority.toLowerCase()] = Array(7).fill(0);
            });
            // Process tickets for unassigned tickets with priority info
            results.forEach(ticket => {
                if (!ticket.assigned_to || ticket.assigned_to.trim() === '') {
                    const createdDate = new Date(ticket.created_at);
                    const dayIndex = createdDate.getDay(); // Sunday=0, Monday=1, ..., Saturday=6
                    // Adjust so that Monday=0, Sunday=6
                    const adjustedDayIndex = dayIndex === 0 ? 6 : dayIndex - 1;

                    // Check if priority exists and is valid
                    const priorityLower = ticket.priority ? ticket.priority.toLowerCase() : 'low';
                    if (priorities.map(e=>e.toLowerCase()).includes(priorityLower)) {
                        
                        weeklyPriorityCounts[priorityLower][adjustedDayIndex]++;
                    }
                }
            });



            // Plot charts with the specified layout
            const layout = {
                width: $('.col-6').width(),
                height: 180,
                margin: { t: 0, b: 0, l: 0, r: 0 },
                xaxis: { visible: false },
                yaxis: { visible: false },
                title: '',
                modebar: {
                    remove: ["zoomin", "zoomout","pan","autoscale","zoom","resetscale","toImage"]
                }
            };
            if($('.supportDesk-container').length>0){
                // Plot each chart
                Plotly.newPlot($('div.on_hold-chart')[0], [{
                    x: weeks,
                    y: weeklyCounts.on_hold,
                    type: 'scatter',
                    mode: 'lines',
                    line: { shape: 'spline' },
                    fill: 'tonexty'
                }], layout);

                Plotly.newPlot($('div.open_tickets')[0], [{
                    x: weeks,
                    y: weeklyCounts.open_tickets,
                    type: 'scatter',
                    mode: 'lines',
                    line: { shape: 'spline', color: `rgb(26, 242, 68)`},
                    fill: 'tonexty'
                }], layout);

                Plotly.newPlot($('div.due_tickets_today')[0], [{
                    x: weeks,
                    y: weeklyCounts.due_tickets_today,
                    type: 'scatter',
                    mode: 'lines',
                    line: { shape: 'spline', color: `rgb(33, 214, 255)`},
                    fill: 'tonexty'
                }], layout);

                Plotly.newPlot($('div.unassigned')[0], [{
                    x: weeks,
                    y: weeklyCounts.unassigned,
                    type: 'scatter',
                    mode: 'lines',
                    line: { shape: 'spline', color: `rgb(217, 116, 27)`},
                    fill: 'tonexty'
                }], layout);

                

                // Prepare data traces for Plotly
                const traces = priorities.map(priority => ({
                    name: priority.charAt(0).toUpperCase() + priority.slice(1),
                    x: daysOfWeek,
                    y: weeklyPriorityCounts[priority.toLowerCase()],
                    type: 'bar'
                }));

                // Plotly stacked bar chart
                Plotly.newPlot($('.unassigned-priorities')[0], traces, {
                    barmode: 'stack',
                    title: {
                        text: i.charts.tickets.unresolved_tickets_by_priority||"Unresolved Tickets by Priority"
                    },
                    xaxis: { title: 'Day of Week' },
                    yaxis: { title: 'Number of Tickets', range: [0, null]},
                    margin: { t: 30, b: 50, l: 50, r: 30 }
                });
            }

            }
        });
    });
    $('.attachment-manager').each((_, e) => {
        const container = $('<div/>').addClass('attachments-manager-files d-flex flex-wrap');
        $(e).append(container);
        const fileInput = $(e).find('input[type="file"]');

        let currentFiles = [];

        fileInput.on('change', function () {
            const files = Array.from(this.files);

            // Filter out duplicates based on name and size
            const newFiles = files.filter(newFile => {
                return !currentFiles.some(existingFile => 
                    existingFile.name === newFile.name && existingFile.size === newFile.size
                );
            });

            // Append only new files
            currentFiles = currentFiles.concat(newFiles);

            // Process each new file
            newFiles.forEach((file) => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const imgSrc = e.target.result;

                        const img = $('<img/>').attr('src', imgSrc).addClass('preview-image');
                        const overlay = $('<div/>').addClass('image-overlay').text(file.name);
                        const closeBtn = $('<span/>').addClass('image-remove').text('X');
                        const imgContainer = $('<div/>').addClass('image-container');

                        imgContainer.append(closeBtn).append(img).append(overlay);
                        container.append(imgContainer);

                        closeBtn.on('click', () => {
                            imgContainer.remove();
                            currentFiles = currentFiles.filter(f => f !== file);
                            const dataTransfer = new DataTransfer();
                            currentFiles.forEach(f => dataTransfer.items.add(f));
                            $(fileInput).prop('files', dataTransfer.files);
                            $(fileInput).trigger('input');
                        });
                    };
                    reader.readAsDataURL(file);
                } else {
                    const fileDiv = $('<div/>').addClass('uploaded-file').text(file.name);
                    container.append(fileDiv);
                }
            });

            // Update the input's FileList
            const dataTransfer = new DataTransfer();
            currentFiles.forEach(f => dataTransfer.items.add(f));
            $(fileInput).prop('files', dataTransfer.files);
            // Do not clear the input value
            // $(this).val('');
        });
    });

});