String.prototype.hashCode=function(){let t,h,e=0;if(0===this.length)return e;for(t=0;t<this.length;t++)h=this.charCodeAt(t),e=(e<<5)-e+h,e|=0;return Math.abs(e)};
const Generators = {
    directions:{
        toTop: 'to top',
        toBottom: 'to bottom',
        toRight: 'to right',
        toLeft: 'to left',
    },
    shape:{
        circle: 'circle',
        ellipse: 'ellipse'
    },
    position: {
        top: 'top',
        left: 'left',
        right: 'right',
        bottom: 'bottom',
        center: 'center'
    },
    /**
     * Generates CSS gradient strings in multiple formats, supporting direction-based
     * (e.g., 'to top') and position-based (percentage stops) gradients, with per-color
     * opacity control.
     *
     * @param {Object} options - Configuration options for the gradient.
     * @param {string} [options.direction=90] - Direction of the pattern
     * @param {Array<Object>} options.gradient - Array of gradient stops, each with:
     *   - position: Position (0-100).
     *   - color: color string (named, hex, rgb, etc.).
     *   - optional opacity: number (0-1) for individual stop opacity.
     * @param {number} [options.opacity=1] - Default opacity applied globally if individual stop opacity isn't specified.
     *
     * @returns {Object} - An object containing CSS gradient strings in various formats:
     *   - default: fallback background color.
     *   - webkit: -webkit-linear-gradient format.
     *   - moz: -moz-linear-gradient format.
     *   - background: standard linear-gradient.
     *   - filter: Microsoft gradient filter for older IE versions.
     */
    linearGradient: (options = {}) => {
        const { gradient = [], opacity = 1, direction=90 } = options;

        // Helper function to convert color to rgba with specified opacity
        function colorToRgba(color, opacity) {
            const ctx = document.createElement('canvas').getContext('2d');
            ctx.fillStyle = color;
            // This line triggers the browser to parse the color string
            ctx.fillRect(0, 0, 1, 1);
            const computedColor = ctx.fillStyle; // fallback for named, hex, rgb, etc.

            ctx.fillStyle = computedColor;
            ctx.fillRect(0, 0, 1, 1);
            const data = ctx.getImageData(0, 0, 1, 1).data;
            return `rgba(${data[0]}, ${data[1]}, ${data[2]}, ${opacity})`;
        }

        // Determine if gradient stops are direction-based ('to top', etc.)
        const isDirectionString = typeof gradient[0]?.position === 'string';

        // Build color stops with rgba, considering individual stop opacity if provided
        const colorStops = gradient.map(g => {
            const stopOpacity = (g.opacity !== undefined) ? g.opacity : opacity;
            const rgbaColor = colorToRgba(g.color, stopOpacity);
            return { position: g.position, color: rgbaColor };
        });

        // Construct gradient direction string
        let directionStr = '';
        if (direction !== undefined) {
            if (typeof direction === 'number') {
                // Degree-based direction
                directionStr = `${direction}deg`;
            } else if (typeof direction === 'string') {
                // String-based direction (e.g., 'to top')
                directionStr = direction;
            }
        } else {
            directionStr = 'to bottom';
        }

        // Build gradient string
        let gradientStr = '';
        if (isDirectionString) {
            // direction-based gradient stops
            gradientStr = `linear-gradient(${directionStr}, ${colorStops.map(c => c.color).join(', ')})`;
        } else {
            // position-based gradient stops
            const stops = colorStops.map(g => {
                const pos = g.position;
                const color = g.color;
                if (typeof pos === 'number') {
                    return `${color} ${pos}%`;
                } else {
                    return `${color}`;
                }
            });
            gradientStr = `linear-gradient(${directionStr}, ${stops.join(', ')})`;
        }

        // For older IE filter, define start and end colors
        const startColor = colorToRgba(
            gradient[0].color,
            (gradient[0].opacity !== undefined) ? gradient[0].opacity : opacity
        );
        const endColor = colorToRgba(
            gradient[gradient.length - 1].color,
            (gradient[gradient.length - 1].opacity !== undefined) ? gradient[gradient.length - 1].opacity : opacity
        );

        // Determine GradientType for filter (0=vertical, 1=horizontal)
        let gradientType = 0;
        if (typeof direction === 'string' && direction.startsWith('to')) {
            if (direction.includes('top')) {
                gradientType = 0; // vertical
            } else if (direction.includes('left')) {
                gradientType = 1; // horizontal
            }
            // Add more logic if needed for other directions
        } else if (typeof direction === 'number') {
            // For degree, approximate direction
            gradientType = (direction >= 45 && direction <= 135) ? 1 : 0;
        }

        return {
            default: 'background-color: #fff;', // fallback
            webkit: `-webkit-linear-gradient(${directionStr}, ${colorStops.map(c => c.color).join(', ')})`,
            moz: `-moz-linear-gradient(${directionStr}, ${colorStops.map(c => c.color).join(', ')})`,
            background: gradientStr,
            filter: `progid:DXImageTransform.Microsoft.gradient(startColorstr='${startColor}', endColorstr='${endColor}', GradientType=${gradientType})`
        };
    },
    /**
     * Generates CSS gradient strings in multiple formats, supporting center-based
     * (radial) gradients, with per-color opacity control.
     *
     * @param {Object} options - Configuration options for the gradient.
     * @param {string} [options.shape='ellipse'] - Shape of the radial gradient ('circle' or 'ellipse').
     * @param {string} [options.position='center'] - Position of the gradient center ('center', 'top', 'left', etc.).
     * @param {Array<Object>} options.gradient - Array of gradient stops, each with:
     *   - position: Position (0-100).
     *   - color: color string (named, hex, rgb, etc.).
     *   - optional opacity: number (0-1) for individual stop opacity.
     * @param {number} [options.opacity=1] - Default opacity applied globally if individual stop opacity isn't specified.
     *
     * @returns {Object} - An object containing CSS gradient strings in various formats:
     *   - default: fallback background color.
     *   - webkit: -webkit-radial-gradient format.
     *   - moz: -moz-radial-gradient format.
     *   - background: standard radial-gradient.
     *   - filter: Microsoft gradient filter for older IE versions.
     */
    radicalGradient: (options = {}) => {
        const { gradient = [], opacity = 1, shape='ellipse', position='center' } = options;

        // Helper function to convert color to rgba with specified opacity
        function colorToRgba(color, opacity) {
            const ctx = document.createElement('canvas').getContext('2d');
            ctx.fillStyle = color;
            const computedColor = ctx.fillStyle;

            ctx.fillStyle = computedColor;
            ctx.fillRect(0, 0, 1, 1);
            const data = ctx.getImageData(0, 0, 1, 1).data;
            return `rgba(${data[0]}, ${data[1]}, ${data[2]}, ${opacity})`;
        }

        // Build color stops with rgba
        const colorStops = gradient.map(g => {
            const colorOpacity = (g.opacity !== undefined) ? g.opacity : opacity;
            const rgbaColor = colorToRgba(g.color, colorOpacity);
            return { position: g.position, color: rgbaColor };
        });

        // Construct radial gradient string
        const stops = colorStops.map(g => {
            const pos = g.position;
            const color = g.color;
            if (typeof pos === 'number') {
                return `${color} ${pos}%`;
            } else {
                return `${color}`;
            }
        }).join(', ');

        // Build the radial gradient CSS strings
        const shapeStr = shape; // 'circle' or 'ellipse'
        const positionStr = position; // e.g., 'center', 'top', etc.
        const gradientStr = `radial-gradient(${shapeStr} at ${positionStr}, ${stops})`;

        // For older IE filter, define start and end colors
        const startColor = colorToRgba(gradient[0].color, (gradient[0].opacity !== undefined) ? gradient[0].opacity : opacity);
        const endColor = colorToRgba(gradient[gradient.length - 1].color, (gradient[gradient.length - 1].opacity !== undefined) ? gradient[gradient.length - 1].opacity : opacity);

        return {
            default: 'background-color: #fff;', // fallback
            webkit: `-webkit-radial-gradient(${shapeStr} at ${positionStr}, ${stops})`,
            moz: `-moz-radial-gradient(${shapeStr} at ${positionStr}, ${stops})`,
            background: gradientStr,
            filter: `progid:DXImageTransform.Microsoft.gradient(startColorstr='${startColor}', endColorstr='${endColor}', GradientType=1)`
        };
    },
    /**
     * Generates a chart
     * @param {HTMLElement} el Parent element
     * @param {Object} cjs ChartJS options
     * @description Use {@link https://www.chartjs.org/docs/latest/getting-started/|ChartJS} reference
     */
    Chart: (el, cjs={})=>new Chart(el,cjs),
    /**
     * Generates a random UUID
     * @param {Number} version UUID version number (1-8)
     * @param {String} [id=''] Name for UUID
     * @returns 
     */
    UUID: async (version, id = '') => {
        switch (version) {
            case 1:
            return generateV1();
            case 2:
            return generateV2();
            case 3:
            return await generateV3Or5('md5', id);
            case 4:
            return generateV4();
            case 5:
            return await generateV3Or5('SHA-1', id);
            case 6:
            return generateV6();
            case 7:
            return generateV7();
            case 8:
            return generateV8();
            default:
            throw new Error('Unsupported UUID version');
        }

        function generateV1() {
            const timestamp = Date.now();
            const randomPart = crypto.getRandomValues(new Uint8Array(8));
            const clockSeq = crypto.getRandomValues(new Uint16Array(1))[0];

            const timeLow = (timestamp & 0xffffffff).toString(16).padStart(8, '0');
            const timeMid = ((timestamp >> 32) & 0xffff).toString(16).padStart(4, '0');
            const timeHighAndVersion = (((timestamp >> 48) & 0x0fff) | 0x1000).toString(16).padStart(4, '0');

            const clockSeqHighAndReserved = ((clockSeq & 0xff00) >> 8 | 0x80).toString(16).padStart(2, '0');
            const clockSeqLow = (clockSeq & 0xff).toString(16).padStart(2, '0');

            const node = [...randomPart].map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 12);

            return `${timeLow}-${timeMid}-${timeHighAndVersion}-${clockSeqHighAndReserved}${clockSeqLow}-${node}`;
        }

        function generateV2() {
            return '000003e8-90ed-21f0-xxxx-325096b39f47'.replace(/x/g, () => Math.floor(Math.random() * 16).toString(16));
        }
        async function generateV3Or5(hashAlgorithm, name) {
            if (!name) {
            throw new Error(`Name must be provided for UUID version ${hashAlgorithm === 'md5' ? 3 : 5}`);
            }
            const namespace = '6ba7b810-9dad-11d1-80b4-00c04fd430c8'; // example namespace
            const data = namespace + name;
            let buf;
            // Assuming md5() accepts a Uint8Array and outputs a hex string
            function md5Bytes(inputBytes) {
            const hexStr = md5(inputBytes); // your existing md5 function
            return hexToUint8Array(hexStr).buffer; // Convert hex to ArrayBuffer
            }

            // Helper function to convert hex string to Uint8Array
            function hexToUint8Array(hex) {
            if (hex.length % 2 !== 0) throw new Error('Invalid hex string');
            const array = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                array[i / 2] = parseInt(hex.substr(i, 2), 16);
            }
            return array;
            }
            if(hashAlgorithm==='md5') buf = md5Bytes(new TextEncoder().encode(data));
            else buf = await crypto.subtle.digest(hashAlgorithm, new TextEncoder().encode(data));
            const bytes = new Uint8Array(buf);
            // Set version and variant bits
            if (hashAlgorithm === 'md5') {
            bytes[6] = (bytes[6] & 0x0f) | 0x30; // version 3 (MD5)
            } else {
            bytes[6] = (bytes[6] & 0x0f) | 0x50; // version 5 (SHA1)
            }
            bytes[8] = (bytes[8] & 0x3f) | 0x80; // RFC variant

            const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
            return `${hex.substr(0,8)}-${hex.substr(8,4)}-${hex.substr(12,4)}-${hex.substr(16,4)}-${hex.substr(20,12)}`;
        }

        function generateV4() {
            const bytes = crypto.getRandomValues(new Uint8Array(16));
            bytes[6] = (bytes[6] & 0x0f) | 0x40; // version 4
            bytes[8] = (bytes[8] & 0x3f) | 0x80; // RFC variant
            const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
            return `${hex.substr(0,8)}-${hex.substr(8,4)}-${hex.substr(12,4)}-${hex.substr(16,4)}-${hex.substr(20,12)}`;
        }

        function generateV6() {
            const bytes = new Uint8Array(16);
            crypto.getRandomValues(bytes);

            // Set version bits (for example, version 6, if you want)
            bytes[6] = (bytes[6] & 0x0f) | 0x60; // version 6 (or change as needed)

            // Set variant bits (RFC 4122 variant)
            bytes[8] = (bytes[8] & 0x3f) | 0x80;

            const hex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
            // Format as UUID string
            return `${hex.substr(0, 8)}-${hex.substr(8, 4)}-${hex.substr(12, 4)}-${hex.substr(16, 4)}-${hex.substr(20, 12)}`;
        }

        function generateV7() {
            const randomBytes = crypto.getRandomValues(new Uint8Array(16));
            // Set version 7 (bits 4-7 of byte 6)
            randomBytes[6] = (randomBytes[6] & 0x0f) | 0x70; // 0b0111_0000
            // Set variant (bits 6-7 of byte 8)
            randomBytes[8] = (randomBytes[8] & 0x3f) | 0x80; // 0b1000_0000
            // Convert to hexadecimal string
            const hexBytes = Array.from(randomBytes).map(b => b.toString(16).padStart(2, '0')).join('');
            // Format as UUID: 8-4-4-4-12
            return `${hexBytes.substring(0,8)}-${hexBytes.substring(8,12)}-${hexBytes.substring(12,16)}-${hexBytes.substring(16,20)}-${hexBytes.substring(20,32)}`;
        }

        function generateV8() {
            const arr = crypto.getRandomValues(new Uint8Array(16));
            // Set version bits to 8 (for version 8, if that's your intent)
            arr[6] = (arr[6] & 0x0f) | 0x80; // version 8
            // Set variant bits
            arr[8] = (arr[8] & 0x3f) | 0x80; // RFC 4122 variant
            const hexStr = Array.from(arr).map(b => b.toString(16).padStart(2, '0')).join('');
            // Format as UUID: 8-4-4-4-12
            return `${hexStr.substring(0,8)}-${hexStr.substring(8,12)}-${hexStr.substring(12,16)}-${hexStr.substring(16,20)}-${hexStr.substring(20,32)}`;
        }
    },
    /**
     * Generates random integers
     * @param {Number} min Minimum number
     * @param {Number} max Maximum number
     * @param {{inclusive:boolean, count: number}} [options={}] Options
     * @returns {Number|Number[]} Single number or array of numbers
     */
    randomInt: (min, max, options = {}) => {
        const { inclusive = false, count = 1 } = options,
        results = [];
        for (let i = 0; i < count; i++) {
            if (inclusive) {
            results.push(Math.floor(Math.random() * (max - min + 1)) + min);
            } else {
            results.push(Math.floor(Math.random() * (max - min)) + min);
            }
        }
        return count === 1 ? results[0] : results;
    },

    /**
     * Generates random floats
     * @param {Number} min Minimum number
     * @param {Number} max Maximum number
     * @param {{inclusive:boolean, count: number}} [options={}] Options
     * @returns {Number|Number[]} Single number or array of numbers
     */
    randomFloat: (min, max, options = {}) => {
        const { inclusive = false, count = 1 } = options,
        results = [];
        for (let i = 0; i < count; i++) {
            let value;
            if (inclusive) value = Math.min(Math.random() * (max - min + 1) + min,max);
            else value = Math.random() * (max - min) + min;
            results.push(value);
        }
        return count === 1 ? results[0] : results;
    },
    /**
     * Generates a random binary string
     * @param {Number} length Length of the binary
     * @returns {String} Binary string
     */
    randomBinary: (length = 8) => {
        let result = '';
        for (let i = 0; i < length; i++) result += Math.round(Math.random());
        return result;
    },
    /**
     * Generates a random hex color
     * @returns {string} Hex color
     */
    hexColor: (count=1) => {
        if(count==1) return `#${Math.floor(Math.random() * 0xffffff).toString(16).padStart(6, '0')}`;
        else {
            const colors = new Set();
            while (colors.size < count) {
                let color;
                do {
                    color = `#${Math.floor(Math.random() * 0xffffff).toString(16).padStart(6, '0')}`;
                } while (colors.has(color));
                colors.add(color);
            }
            return Array.from(colors);
        }
    },
    /**
     * Generates a random boolean
     * @returns {Boolean} Random boolean
     */
    randomBoolean: ()=>Math.random()>=0.5,
    parseBytes: (bytes) => {
        if (bytes === 0) return '0B';
        const k = 1024,
        sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
        i = Math.floor(Math.log(bytes) / Math.log(k)),
        value = bytes / Math.pow(k, i);
        // Optional: round to 2 decimal places
        return `${value.toFixed(2)} ${sizes[i]}`;
    }
}